배열은 포인터라고도 한다.

- 배열을 선언하고 *(애스터리스크)로 역참조를 했을 시 배열의 첫번 째 요소의 주소값에 접근하여 값을 가져옴
포인터를 선언하고 배열을 저장한 뒤 *(애스터리스크)로 역참조를 했을 시 포인터가 가리키는 배열의 첫번 째 요소의 주소값에 접근하여 값을 가져옴

int *ptr = arr; 처럼 배열을 포인터에 바로 할당할 수 있는데, 단 자료형이 같아야 하고 1차원 배열이어야 하며 *(애스터리스크)가 한 개인 단일 포인터이어야 한다.

근데 배열과 포인터는 분명히 차이점이 존재한다. ( https://vkein.tistory.com/entry/11배열과-포인터-포인터와-배열-차이 )

1. 포인터는 변수인데 배열은 상수이다.
- 포인터는 고유의 메모리를 차지하고 있고 const 키워드를 이용해 상수 설정을 하지 않았다면 언제든지 다른 대상을 가리킬수 있지만 배열은 선언할 때 그 위치가 이미 고정되어있으므로 다른 대상을 가리킬 수 없다. 배열의 이름으로는 배열의 첫번째 요소의 주소를 읽을 수 있을 뿐

2. 포인터가 가리키는 배열의 크기는 동적으로 결정할 수 있지만 배열의 이름이 가리키는 배열의 크기는 선언할 때 저적으로 결정됩니다.
- 고정된 길이의 배열이 필요하면 int arr[n]; 선언문으로 배열을 생성하는 것이 편리하고
  가변길이의 배열이 필요하면 int* 형의 포인터 변수를 선언한 후 malloc 함수로 메모리를 할당해서 사용해야 합니다.
  포인터로 할당한 배열은 실행 중에라도 realloc 함수로 크기를 재할당하여 변경할 수 있습니다.

3.배열은 배열 자체가 크기 때문에 함수의 인수로 전달할 수 없지만, 포인터는 대상하는 상대가 무엇이든간에 4byte의 크기밖에 차지하지 않으므로 함수로 전달할 수 있다.
- 배열을 함수로 전달할 때는 반드시 포인터를 사용해야 한다.

4. 배열로 요소를 읽는 것과 포인터로 대상체를 읽는 동작의 속도 차이가 있다.
- 배열의 연산은 매번 배열의 첫번째 요소부터 출발하지만 포인터는 대상체로 직접 이동해서 바로 읽으므로 액세스 속도가 빠릅니다.
ex) *ptr은 포인터 변수인 ptr이 가리키는 곳을 바로 읽지만 arr[n]은 *(ar+n)으로 먼저 번지를 더한 후 읽어야 하므로 조금 느립니다. 즉, 포인터가 배열보다 두 배 정도 빠릅니다.

-

lvalue와 rvalue 차이

http://jeremyko.blogspot.com/2012/08/lvalue-rvalue.html

배열 이름과 포인터 차이
https://showx123.tistory.com/14
